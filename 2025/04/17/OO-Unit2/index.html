<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OO-Unit2 | Boomfreezing</title><meta name="author" content="Boom_freezing"><meta name="copyright" content="Boom_freezing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="“每天坐电梯，你有想过电梯调度是怎么实现的吗？”——多线程实现电梯调度策略相关知识梳理……">
<meta property="og:type" content="article">
<meta property="og:title" content="OO-Unit2">
<meta property="og:url" content="http://boomfreezing.github.io/2025/04/17/OO-Unit2/index.html">
<meta property="og:site_name" content="Boomfreezing">
<meta property="og:description" content="“每天坐电梯，你有想过电梯调度是怎么实现的吗？”——多线程实现电梯调度策略相关知识梳理……">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://boomfreezing.github.io/images/OO_Unit2/cover1.png">
<meta property="article:published_time" content="2025-04-17T09:37:47.000Z">
<meta property="article:modified_time" content="2025-04-20T09:42:16.994Z">
<meta property="article:author" content="Boom_freezing">
<meta property="article:tag" content="面向对象OO">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="电梯调度">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://boomfreezing.github.io/images/OO_Unit2/cover1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OO-Unit2",
  "url": "http://boomfreezing.github.io/2025/04/17/OO-Unit2/",
  "image": "http://boomfreezing.github.io/images/OO_Unit2/cover1.png",
  "datePublished": "2025-04-17T09:37:47.000Z",
  "dateModified": "2025-04-20T09:42:16.994Z",
  "author": [
    {
      "@type": "Person",
      "name": "Boom_freezing",
      "url": "http://boomfreezing.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="http://boomfreezing.github.io/2025/04/17/OO-Unit2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":10,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OO-Unit2',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/header.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/OO_Unit2/cover1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Boomfreezing</span></a><a class="nav-page-title" href="/"><span class="site-name">OO-Unit2</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">OO-Unit2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-17T09:37:47.000Z" title="发表于 2025-04-17 17:37:47">2025-04-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-20T09:42:16.994Z" title="更新于 2025-04-20 17:42:16">2025-04-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OO/">OO</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="BUAA-OO-Unit2"><a href="#BUAA-OO-Unit2" class="headerlink" title="BUAA_OO_Unit2"></a>BUAA_OO_Unit2</h1><div style="text-align: right;">作者：弎轮轟</div>

<hr>
<h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><h3 id="一-任务目标："><a href="#一-任务目标：" class="headerlink" title="一.任务目标："></a>一.任务目标：</h3><ul>
<li>系统从标准输入中读入乘客请求信息（起点层，终点楼层），<strong>请求调度器</strong>会根据此时电梯运行状态将乘客请求合理分配给<strong>乘客指定电梯</strong>。被分配请求的电梯会经过<strong>上下行，开关门，乘客进入&#x2F;离开电梯</strong>等动作将乘客从起点层运送到终点层</li>
</ul>
<h3 id="二-实现方法："><a href="#二-实现方法：" class="headerlink" title="二.实现方法："></a>二.实现方法：</h3><ul>
<li><p>知识分区：多线程，多个线程对共享对象同时进行读和写可能会出现不一致的情况，因此需要对方法或对象进行加锁，确保每次最多一个线程对共享对象进行操作</p>
</li>
<li><p>管程法：在两个线程之间设置<strong>中间仓库</strong>，线程之间不会相互调用，所有交互通过仓库完成</p>
</li>
<li><p>生产者-消费者模式：</p>
<ul>
<li>生产者：请求的生产者，<strong>产出请求</strong>的线程</li>
<li>消费者：请求的消费者，<strong>解决请求</strong>的线程</li>
<li>分析：本次作业需要用到<strong>两次</strong>生产者-消费者模型，在<code>InputHandler</code>输入线程和<code>DispatchThread</code>调度线程之间，输入线程是生产者，调度线程是消费者；在<code>DispatchThread</code>调度线程和<code>Elevator</code>电梯线程之间，调度线程是生产者，电梯线程是消费者</li>
</ul>
</li>
</ul>
<h3 id="三-思路阐释："><a href="#三-思路阐释：" class="headerlink" title="三.思路阐释："></a>三.思路阐释：</h3><ul>
<li>输入线程<code>InputHandler</code>解析请求并生成<code>Person</code>类请求并将其<strong>放入</strong>总仓库<code>OrderQueue</code></li>
<li>调度线程<code>DispatchThread</code>从总仓库<code>OrderQueue</code>中<strong>拉取</strong>请求，并将请求<strong>放入</strong>给指定的电梯仓库<code>ProcessingQueue_n</code></li>
<li>电梯线程<code>Elevator</code>从其对应的电梯仓库<code>ProcessingQueue_n</code>中<strong>拉取</strong>请求并<strong>解决</strong>请求</li>
</ul>
<p><img src="/images/OO_Unit2/1_1.png"></p>
<ul>
<li>由于需要六部电梯同时调度，因此设置<strong>六个电梯线程</strong>及对应的<strong>六个电梯仓库</strong></li>
<li>电梯线程同时也是输出线程，所有的输出均位于电梯线程的各个方法中</li>
<li>为实现功能分离，设置<code>Strategy</code>类专门分析电梯当前状态并给出对应的<code>Advice</code>，采用<strong>LOOK</strong>算法，综合当前<strong>电梯内</strong>和<strong>电梯外</strong>(即电梯对应仓库)的情况给出下一步最佳运行策略</li>
<li><code>Advice</code>包括：<code>OVER</code>结束线程、<code>MOVE</code>移动、<code>REVERSE</code>转向、<code>OPEN</code>开门、<code>WAIT</code>等待</li>
</ul>
<h3 id="四-代码实现："><a href="#四-代码实现：" class="headerlink" title="四.代码实现："></a>四.代码实现：</h3><p><img src="/images/OO_Unit2/1_2.png"></p>
<ul>
<li><code>MainClass</code>类：主类，实例化输入线程<code>InputHandler</code>、总仓库<code>OrderQueue</code>、6个调度线程<code>DispatchThread</code>、6个电梯仓库<code>ProcessingQueue</code>、电梯线程<code>Elevator</code>，并调用<code>.start()</code>方法让全部线程运行</li>
<li><code>Person</code>类：乘客请求的实例化类，其中包含请求的各种属性，包括：乘客ID、优先级、起始楼层、目标楼层、指定电梯ID</li>
<li><code>InputHandler</code>类：输入线程类，解析输入的乘客请求并将其实例化为一个<code>Person</code>，将实例化的请求存入总仓库<code>OrderQueue</code></li>
<li><code>OrderQueue</code>类：总仓库类，存储所有电梯的全部请求，使用<code>ArrayList&lt;Person&gt;</code>存储，在这里存储时可以根据优先级排序，让优先级高的请求排在队列的前面，确保其先被调度</li>
<li><code>DispatchThread</code>类：调度类，从总仓库中按序取出乘客请求，并按照请求指定的电梯ID号将请求存入对应电梯的电梯仓库</li>
<li><code>ProcessingQueue</code>类：电梯仓库类，存储对应电梯的全部请求，使用<code>HashMap&lt;String,ArrayList&lt;Person&gt;&gt;</code>来存储不同楼层对应的全部乘客请求</li>
<li><code>Elevator</code>类：电梯线程类，从其对应的电梯仓库中取出请求，并调用<code>Strategy</code>类中获取当前最佳建议，解决乘客请求或接取新的乘客请求</li>
<li><code>Advice</code>类：建议枚举类，包括五种建议</li>
<li><code>Strategy</code>类：建议类，以当前电梯仓库和电梯内部的状态为参数，根据<strong>LOOK</strong>算法返回建议</li>
</ul>
<h3 id="五-BUG分析："><a href="#五-BUG分析：" class="headerlink" title="五.BUG分析："></a>五.BUG分析：</h3><ul>
<li><p>两个出现bug的强测样例均是因为：在<code>strategy</code>策略类中，我使用了for循环来遍历查询<code>queue.getOrders()</code>(本质上是HashMap)，虽然我在<code>ProcessingQueue</code>类中的<code>getOrders()</code>方法加了<code>sychronized</code>关键字，但是我忽略了重要的一点——在for循环的两次取值的中间可能会有其他线程修改<code>queue</code>，导致出现如下报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread-3&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">	at java.util.HashMap$HashIterator.nextNode(HashMap.java:<span class="number">1445</span>)</span><br><span class="line">	at java.util.HashMap$KeyIterator.next(HashMap.java:<span class="number">1469</span>)</span><br><span class="line">	at Strategy.hasReqInOriginDirection(Strategy.java:<span class="number">57</span>)</span><br><span class="line">	at Strategy.getAdvice(Strategy.java:<span class="number">27</span>)</span><br><span class="line">	at Elevator.run(Elevator.java:<span class="number">34</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>

<p>之前代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String floor : queue.getOrders().keySet()) &#123;</span><br><span class="line">	<span class="comment">//判断是否有请求发出地在电梯运行方向的“前方”                </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是我采取使用<code>sychnoized</code>同步块包裹的方法为<code>queue</code>加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (queue) &#123; <span class="comment">// 与修改操作共享同一锁</span></span><br><span class="line">	<span class="keyword">for</span> (String floor : queue.getOrders().keySet()) &#123;</span><br><span class="line">    	<span class="comment">//判断是否有请求发出地在电梯运行方向的“前方”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="六-复杂度及耦合情况"><a href="#六-复杂度及耦合情况" class="headerlink" title="六.复杂度及耦合情况"></a>六.复杂度及耦合情况</h3><p><img src="/images/OO_Unit2/1_3.png"></p>
<ul>
<li><p><strong>OCavg (平均循环复杂度)</strong>：3.14（项目整体）<br>正常范围应≤4，但<code>Elevator</code>和<code>Strategy</code>两个类高达6.00，表明这两个类的方法逻辑复杂。</p>
<p>原因：<code>Elevator</code>和<code>Strategy</code>两个类及其内部方法承担过多责任，且内部的单个方法(例如<code>openAndClose()</code>和<code>getAdvice()</code>)包含了大量的条件分支，多层的<code>if-else</code>及嵌套循环</p>
</li>
<li><p><strong>OCmax (最大方法复杂度)</strong>：7.25<br>存在至少一个方法复杂度极高（接近8）：<code>Elevator</code>、<code>Strategy</code>、<code>Person</code>三个类复杂度均超过10</p>
<p>原因：内部方法过于复杂，重复度过高</p>
</li>
<li><p><strong>WMC (加权方法复杂度)</strong>：12.56<br>类整体复杂度尚可，主要是<code>Elevator</code>和<code>Strategy</code>两个类导致较高</p>
</li>
</ul>
<h3 id="七-优缺点分析"><a href="#七-优缺点分析" class="headerlink" title="七.优缺点分析"></a>七.优缺点分析</h3><ul>
<li>优点：<ul>
<li>各个线程和仓库之间分工较为明确，代码可读性较好</li>
<li>采用功能策略分离，避免单个类承担过多责任</li>
<li>设置了调度线程和<strong>总-副</strong>仓库机制，增强代码的可迭代性和可扩展性</li>
</ul>
</li>
<li>缺点：<ul>
<li><code>Elevator</code>和<code>Strategy</code>两个类的复杂度过高，嵌套循环过多</li>
<li>直接在方法上加锁，导致锁粒度过粗，让本可以并行计算的代码强制串行执行，降低并发性能</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><h3 id="一-任务目标：-1"><a href="#一-任务目标：-1" class="headerlink" title="一.任务目标："></a>一.任务目标：</h3><ul>
<li>系统从标准输入中读入乘客请求信息（起点层，终点楼层），<strong>请求调度器</strong>会根据此时电梯运行状态将乘客请求合理分配给<strong>某部电梯</strong>。被分配请求的电梯会经过<strong>上下行，开关门，乘客进入&#x2F;离开电梯</strong>等动作将乘客从起点层运送到终点层</li>
<li>新增：<ul>
<li>乘客请求不再指定电梯，需要调度器为请求分配电梯</li>
<li>新增一种<strong>临时调度</strong>请求，接收到临时调度的电梯需要<strong>及时</strong>反应，并到请求<strong>指定的楼层</strong>完成检修，请求完成之后恢复正常接客</li>
</ul>
</li>
</ul>
<h3 id="二-思路阐释："><a href="#二-思路阐释：" class="headerlink" title="二.思路阐释："></a>二.思路阐释：</h3><p><img src="/images/OO_Unit2/2_1.png"></p>
<ul>
<li>乘客不再指定电梯，则需要在调度线程分派请求时增加<strong>分派策略</strong>。<ul>
<li>本人选择<strong>均分</strong>策略：在输入线程解析每个请求时记录请求的添加序号，在调度器分派时调用序号模6，所得余数就是指定的电梯号，这样可以确保每个电梯都可以接受到请求，避免某部电梯任务过重</li>
<li>如果上一步指定的电梯正处于临时调度，则让序号加一后再次模6(得到下一个电梯ID)，若新分配的电梯也处于临时调度，则<strong>重复</strong>当前步骤，直到找到可以使用的电梯。</li>
<li>如果遍历了6部电梯后仍然没有找到可用的电梯，则将该请求重新<strong>打回总仓库</strong>的请求队列，等待下一轮调度。由于在上一次作业中，本人在总仓库队列进行了优先级排列，这也就意味着这个即将被打回的请求<strong>可能</strong>还是总队列中优先级最高的请求，从而被打回后仍然排在队首，导致后面的请求需要一直等待，直到这个请求被分派出去或出现优先级更高的请求来打破阻塞，因此在将其放回总队列之前先<code>sleep()</code>一段时间，确保后面的请求可以被<strong>放走</strong></li>
</ul>
</li>
<li>新增的调度请求是区别于乘客请求的新型请求，需单独增加处理：<ul>
<li>设置临时调度<code>Fix</code>类，存储临时调度请求的各种信息</li>
<li>在输入线程解析请求后，将临时调度请求也存入总仓库，因为临时调度需要及时反应，因此电梯线程不经过调度器和电梯仓库，而是<strong>直接</strong>从总仓库中拉取临时请求</li>
<li>为了将电梯的正常运行和临时调度状态区分开来，设置了一个<code>FixStrategy</code>临时调度策略类，当电梯检测到临时调度请求时，调用<code>FixStrategy</code>临时调度策略类，而不是<code>Strategy</code>策略类，专门返回临时调度的几种电梯运行建议</li>
<li>当到达临时调度请求指定的检修楼层之后，电梯内的全部乘客都需要下电梯。如果当前乘客已经到达了目标楼层，则正常输出；若当前乘客没有到达目标楼层，则将其起始楼层设置为当前楼层，并将其<strong>打回</strong>总仓库的请求队列，等待重新分配电梯</li>
</ul>
</li>
</ul>
<h3 id="三-代码实现："><a href="#三-代码实现：" class="headerlink" title="三.代码实现："></a>三.代码实现：</h3><p><img src="/images/OO_Unit2/2_2.png"></p>
<ul>
<li><code>Fix</code>类：临时调度请求的实例化类，其中包含请求的各种属性，包括：待检修电梯ID、检修运行速度、检修目标楼层</li>
<li><code>InputHandler</code>类：输入线程类，增加对临时调度请求的解析，并将临时调度请求存入总仓库</li>
<li><code>OrderQueue</code>类：总仓库类，新增使用<code>HashMap&lt;Integer,ArrayList&lt;Fix&gt;&gt;</code>存储不同电梯的全部临时调度请求，增加<code>reDispatch</code>方法，将需要重新分派的乘客请求放回队列。增加对6个电梯仓库的存储：因为在临时调度请求到来时，电梯线程可能在电梯仓库的<code>waitOrders()</code>方法处等待，因此需要在这里将其唤醒，及时反应临时调度请求</li>
<li><code>DispatchThread</code>类：增加对<strong>均分策略</strong>的实现，增加对放回请求的实现。修改发出线程结束的条件，需要确保总仓库中的乘客和临时调度两种请求全部完成分配，且不会再有乘客请求被打回重新分派</li>
<li><code>ProcessingQueue</code>类：电梯仓库类，增加<code>inFix</code>标志位，用于确认对应的电梯是否处于临时调度(检修)状态，当电梯开始临时调度时会将其置为<code>true</code>，当调度结束时会将其置为<code>false</code>，被调度线程调用来判断是否可以给对应电梯分派乘客请求</li>
<li><code>Elevator</code>类：电梯线程类，用<code>ArrayList&lt;Fix&gt;</code>存储临时调度请求，如果临时调度请求非空，则将所有已分配给该电梯但没有上电梯的乘客打回总仓库重新分配，且调用<code>FixStrategy</code>类来获取最佳建议。增加<code>elevatorFix</code>方法处理临时调度请求过程中电梯内的全部乘客。电梯线程结束条件增加，需要总仓库中没有新的检修请求，当前所有检修请求全部完成</li>
<li><code>Advice</code>类：建议枚举类，新增<code>FIX</code>建议，表示需要进行检修</li>
<li><code>FixStrategy</code>类：临时调度建议类，以电梯当前状态为参数返回最佳建议，建议仅包括三种，<code>FIX</code>检修、<code>REVERSE</code>转向、<code>MOVE</code>继续移动</li>
</ul>
<h3 id="四-BUG分析："><a href="#四-BUG分析：" class="headerlink" title="四.BUG分析："></a>四.BUG分析：</h3><ul>
<li><p>在题目要求的<code>RECEIVE</code>部分中有这样的约束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">4</span>：</span><br><span class="line">    [   <span class="number">1.0150</span>]RECEIVE-<span class="number">10</span>-<span class="number">1</span></span><br><span class="line">    [   <span class="number">1.0170</span>]ARRIVE-B1-<span class="number">1</span>    ← ARRIVE标记的是到达状态，假设此时电梯运行速度是每层<span class="number">0.</span>4s，在<span class="number">0.</span>6170s时电梯尚未收到RECEIVE，无法移动，不合法！</span><br></pre></td></tr></table></figure>

<p>即在将乘客请求分派并输出<code>RECEIVE</code>后至少经过0.4s后才能让对应的电梯开始移动</p>
<p>而在某样例中，本人的代码输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2.5710</span>]RECEIVE-<span class="number">60</span>-<span class="number">1</span></span><br><span class="line">[<span class="number">2.9700</span>]ARRIVE-F2-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>显然违反了题目中的要求：尽管输出顺序正确，但从<code>RECEIVE</code>到<code>ARRIVE</code>的时间为0.399s，时间不足0.4s，也就是“抢跑”</p>
<p>在成功分派之后，本人的原本的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">processMap.get(elevatorId).push(psg);<span class="comment">//将乘客请求放入对应的电梯仓库</span></span><br><span class="line">TimableOutput.println(<span class="string">&quot;RECEIVE-&quot;</span> + psg.getPassengerID() + <span class="string">&quot;-&quot;</span> + elevatorId);<span class="comment">//输出RECEIVE</span></span><br></pre></td></tr></table></figure>

<p>分析上面的代码，现将乘客放入电梯仓库，然后输出<code>RECEIVE</code>表示乘客请求已经分派，乍一看逻辑确实正确，但仔细一想却又能发现问题所在：乘客请求被放入电梯仓库也就意味着电梯随时可以从中将其取出，然而我们并不知道调度线程的<code>RECEIVE</code>输出和电梯线程的<code>ARRIVE</code>输出哪个先来，事实证明是<code>ARRIVE</code>输出先来，导致时间间隔变短。所以正确顺序应该是先输出<code>RECEIVE</code>，然后再将乘客请求放入电梯仓库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TimableOutput.println(<span class="string">&quot;RECEIVE-&quot;</span> + psg.getPassengerID() + <span class="string">&quot;-&quot;</span> + elevatorId);<span class="comment">//先输出</span></span><br><span class="line">processMap.get(elevatorId).push(psg);<span class="comment">//后放入</span></span><br></pre></td></tr></table></figure>

<p>虽然只差了0.001s，但确实不满足题目要求。这个BUG在第一次作业中没有出现，却在这里出现，由此可见多线程的复杂多变性</p>
</li>
</ul>
<h3 id="五-复杂度及耦合情况"><a href="#五-复杂度及耦合情况" class="headerlink" title="五.复杂度及耦合情况"></a>五.复杂度及耦合情况</h3><p><img src="/images/OO_Unit2/2_3.png"></p>
<ul>
<li><p><strong>OCavg (平均循环复杂度)</strong>：3.09（项目整体）<br>正常范围应≤4，但<code>Elevator</code>和<code>Strategy</code>两个类高达6.00，表明这两个类的方法逻辑复杂。</p>
<p>原因：<code>Elevator</code>和<code>Strategy</code>两个类及其内部方法承担过多责任，且内部的单个方法(例如<code>openAndClose()</code>和<code>getAdvice()</code>)包含了大量的条件分支，多层的<code>if-else</code>及嵌套循环</p>
</li>
<li><p><strong>OCmax (最大方法复杂度)</strong>：8.10<br>多个一个方法复杂度极高（&gt;&#x3D;8）：<code>Elevator</code>、<code>Strategy</code>、<code>Person</code>、<code>Fix</code>四个类复杂度均超过10</p>
<p>原因：内部方法过于复杂，多处涉及深层嵌套或复杂条件逻辑</p>
</li>
<li><p><strong>WMC (加权方法复杂度)</strong>：16.00<br>系统整体功能密度较高，<code>Elevator</code>和<code>Strategy</code>均为高风险代码段，过高的复杂度导致”上帝对象”(God Object)反模式的出现【即指在面向对象设计中，某个类承担了<strong>过多的职责</strong>，成为系统中<strong>过度中心化</strong>的庞然大物。这种现象会严重破坏软件的可维护性和扩展性】</p>
</li>
</ul>
<h3 id="六-优缺点分析"><a href="#六-优缺点分析" class="headerlink" title="六.优缺点分析"></a>六.优缺点分析</h3><ul>
<li>优点：<ul>
<li>模块化设计将不同的功能封装到不同的类中，这种模块化设计使得代码结构清晰，易于理解和维护</li>
<li>只在第一次作业代码的基础上进行增添修改，避免了大规模的重构</li>
</ul>
</li>
<li>缺点：<ul>
<li>在<code>DispatchThread</code>类中，调度算法简单，只是按照顺序依次尝试将乘客分配到可用的电梯中，可能会导致电梯的负载不均衡，影响系统的整体性能</li>
<li>部分方法的代码过长，如 <code>Elevator</code> 类的 <code>openAndClose</code> 方法，包含了大量的逻辑，不利于代码的理解和维护</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><h3 id="一-任务目标：-2"><a href="#一-任务目标：-2" class="headerlink" title="一.任务目标："></a>一.任务目标：</h3><ul>
<li>系统从标准输入中读入乘客请求信息（起点层，终点楼层），<strong>请求调度器</strong>会根据此时电梯运行状态将乘客请求合理分配给<strong>某部电梯</strong>。被分配请求的电梯会经过<strong>上下行，开关门，乘客进入&#x2F;离开电梯</strong>等动作将乘客从起点层运送到终点层</li>
<li>新增：<ul>
<li>新增一种<strong>双轿厢改造</strong>请求，接收到双轿厢的电梯需要<strong>及时</strong>反应，与另一个指定的电梯轿厢完成<strong>合并</strong>，实现“一井双轿厢”，请求完成之后两个轿厢各自在指定的允许范围内正常接送客人</li>
</ul>
</li>
</ul>
<h3 id="二-思路阐释：-1"><a href="#二-思路阐释：-1" class="headerlink" title="二.思路阐释："></a>二.思路阐释：</h3><p><img src="/images/OO_Unit2/3_1.png"></p>
<ul>
<li>本次新增的<strong>双轿厢改造请求</strong>与第二次作业的<strong>临时调度请求</strong>实现类似，均作为一种新的请求需要几个线程配合并完成对应操作解决请求<ul>
<li>设置<code>Update</code>类用来存储双轿厢改造请求的各类信息</li>
<li>由于电梯轿厢改造需要两个电梯线程相互配合实现，本质上还是线程之间的交互，所以沿用第一次作业的“管程法”，即设置一个<strong>中间仓库</strong>管理合并的两个电梯轿厢，因此设置<code>UpdateProcess</code>类来控制何时开始改造、何时结束改造</li>
<li>由于需要保证电梯对双轿厢改造请求的及时响应，同样地，电梯直接从总仓库中拉取对应的双轿厢改造请求</li>
<li>在实现双轿厢改造后需要控制轿厢在新的指定范围内移动：在<code>Strategy</code>策略类中需要识别当前电梯是否<strong>处于改造状态</strong>或<strong>已经经过改造</strong>，在开门下电梯时需要判断是否在共享层，如果在共享层需要判断是否有<strong>跨越共享层</strong>的乘客需求；在每次返回<code>MOVE</code>建议前均需要判断移动的下一层是否为共享层，如果是共享层则需要判断共享层是否被<strong>占领</strong>，如果被占领则等待；在识别是否有请求在移动方向前方时，需要判断这个请求是否在<strong>指定范围</strong>内</li>
<li>在实现双轿厢改造后为了防止上下两个轿厢在中间的共享层相撞，需要占领共享层的电梯主动让出位置：在<code>Strategy</code>策略类返回<code>WAIT</code>命令之前，检测当前电梯是否处于共享楼层，如果正处于共享楼层，则强制要求该电梯“<strong>让出</strong>“共享层，即不要让任何一个轿厢在共享楼层停留</li>
</ul>
</li>
</ul>
<h3 id="三-代码实现：-1"><a href="#三-代码实现：-1" class="headerlink" title="三.代码实现："></a>三.代码实现：</h3><p><img src="/images/OO_Unit2/3_2.png"></p>
<ul>
<li><code>Update</code>类：双轿厢改造请求的实例化类，其中包含请求的各种属性，包括：第一个电梯ID、第二个电梯ID、共享楼层</li>
<li><code>InputHandler</code>类：输入线程类，增加对双轿厢改造请求的解析，并将双轿厢改造请求存入总仓库</li>
<li><code>OrderQueue</code>类：总仓库类，新增使用<code>HashMap&lt;Integer,UpdateProcess&gt;</code>存储不同电梯的全部双轿厢改造请求</li>
<li><code>DispatchThread</code>类：在<strong>均分策略</strong>的基础上增加对是否完成过双轿厢改的判断，从而实现不同的分派。增加发出线程结束的条件，需要确保电梯现在和可见的将来(总仓库中)没有改造请求，且电梯仓库和电梯内全部请求完成</li>
<li><code>ProcessingQueue</code>类：电梯仓库类，增加<code>updated</code>标志位，用于确认对应的电梯是否进行过双轿厢改造，当电梯完成改造后将其置为<code>true</code>，被调度线程调用来判断给电梯使用哪种分派(普通or改造)</li>
<li><code>Elevator</code>类：电梯线程类，存储双轿厢改造请求，如果双轿厢改造请求非空，则将所有已分配给该电梯但没有上电梯的乘客打回总仓库重新分配，让所有电梯内乘客下电梯，设置<code>specialOpenAndClose</code>方法用于改造后电梯的开关门操作</li>
<li><code>UpdateProcess</code>类：电梯改造仓库类，设置多个标志位，确保在两个电梯准备好的情况下输出<code>BEGIN</code>；确保在两个电梯全部完成改造的情况下输出<code>END</code>；时刻监视共享楼层的占领状态，保证两个轿厢不会碰撞</li>
<li><code>Advice</code>类：建议枚举类，新增<code>WAIT2</code>建议，表示电梯线程需要在改造仓库处等待；新增<code>OUT</code>建议，表示电梯线程需要立刻从共享楼层移开</li>
<li><code>Strategy</code>类：建议类，对其中的每个方法都要增加双轿厢改造的相关判断，在改造完成后，在共享楼层处需要让跨越共享楼层的乘客也下电梯，在移动前方是共享楼层时需要判断共享楼层是否被占领，在接取乘客请求时需要判断其起始楼层是否在轿厢的移动范围内</li>
</ul>
<h3 id="四-BUG分析：-1"><a href="#四-BUG分析：-1" class="headerlink" title="四.BUG分析："></a>四.BUG分析：</h3><p>由于线程以及仓库之间的相互隔离，导致某些情况下电梯在某个仓库下进行等待，当另外一种类型的请求等待解决时无法将线程唤醒，导致从<code>update</code>请求<code>ACCEPT</code>到<code>BEGIN</code>的间隔时间超过规定时间限制</p>
<p>因此需要在请求出现时在<code>OrderQueue</code>总仓库处对电梯线程进行专门的唤醒操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpdateProcess</span> <span class="variable">updateProcess</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateProcess</span>(update);</span><br><span class="line">updateProcessHashMap.put(update.getFirstID(), updateProcess);</span><br><span class="line"><span class="comment">// 通知对应电梯的 ProcessingQueue</span></span><br><span class="line"><span class="type">ProcessingQueue</span> <span class="variable">queue1</span> <span class="operator">=</span> processingQueues.get(update.getFirstID());</span><br><span class="line"><span class="keyword">if</span> (queue1 != <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="comment">//唤醒第一个电梯</span></span><br><span class="line">	<span class="keyword">synchronized</span> (queue1) &#123;</span><br><span class="line">		queue1.notifyAll();<span class="comment">//专门唤醒电梯</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">notifyAll();</span><br></pre></td></tr></table></figure>

<h3 id="五-复杂度及耦合情况-1"><a href="#五-复杂度及耦合情况-1" class="headerlink" title="五.复杂度及耦合情况"></a>五.复杂度及耦合情况</h3><p><img src="/images/OO_Unit2/3_3.png"></p>
<ul>
<li><p><strong>OCavg (平均循环复杂度)</strong>：3.01（项目整体）<br>正常范围应≤4，但<code>Elevator</code>和<code>Strategy</code>这两个类的值偏高，说明其中的方法逻辑复杂</p>
<p>原因：<code>Elevator</code>和<code>Strategy</code>两个类及其内部方法承担过多责任，且内部存在多个方法需要调用较多其他方法来完成功能，导致该类的维护和理解难度高</p>
</li>
<li><p><strong>OCmax (最大方法复杂度)</strong>：7.92<br>多个一个方法复杂度极高（&gt;&#x3D;8）：<code>DispatchThread</code>、<code>Elevator</code>、<code>Strategy</code>、<code>Person</code>、<code>Fix</code>四个类复杂度均超过10</p>
<p>原因：内部方法过于复杂，多处涉及深层嵌套或复杂条件逻辑，需要进一步拆分或优化</p>
</li>
<li><p><strong>WMC (加权方法复杂度)</strong>：22.46<br>系统整体功能密度较高，<code>Elevator</code>和<code>Strategy</code>为高风险代码段，在本次迭代后<code>Person</code>类的复杂度也较高，可能是因为<code>if-else</code>及<code>switch</code>的分支过多</p>
</li>
</ul>
<h3 id="六-优缺点分析-1"><a href="#六-优缺点分析-1" class="headerlink" title="六.优缺点分析"></a>六.优缺点分析</h3><ul>
<li><p>优点：</p>
<ul>
<li><p>延续了前两次作业的基本思路，整体架构较为清晰</p>
</li>
<li><p>只在上一次作业代码的基础上增添了部分代码，避免了大规模的重构</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>某些类的任务过重、耦合度过高，导致整体复杂度和耦合度被拉高</li>
<li>代码经过三次迭代后，命名规则混乱，导致代码的可读性较差</li>
</ul>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="一-时序图"><a href="#一-时序图" class="headerlink" title="一.时序图"></a>一.时序图</h3><p><img src="/images/OO_Unit2/4_1.png"></p>
<h3 id="二-锁与同步块"><a href="#二-锁与同步块" class="headerlink" title="二.锁与同步块"></a>二.锁与同步块</h3><ul>
<li>本人主要是对仓库中<strong>调用共享对象</strong>的方法加<code>synchronized</code>关键字来确保线程之间的互斥访问</li>
<li>在<code>Strategy</code>策略类中，针对<code>for</code>循环访问共享对象，本人使用了<code>synchronized</code>同步块包裹循环语句，以此避免在两次循环遍历之间有其他线程对访问对象进行改造；当然在这里也可以直接使用<strong>迭代器</strong>，因为迭代器的实现采用了安全的遍历方式，它在内部维护了一个独立的遍历状态，与被遍历对象的修改操作相互隔离，避免了在遍历过程中出现数据不一致的情况</li>
<li>锁与同步块之间的关系<ul>
<li>锁可以保证不同线程互斥访问同步块内调用的共享对象和资源</li>
<li>锁可以界定临界区的范围，通过限定同步块的大小控制并发的粒度</li>
</ul>
</li>
</ul>
<h3 id="三-调度器设计"><a href="#三-调度器设计" class="headerlink" title="三.调度器设计"></a>三.调度器设计</h3><p>在上述几个部分的<strong>思路阐释</strong>部分已经对本人的调度器设计进行了详细的剖析，在此进行总结概括：</p>
<ul>
<li><strong>均分策略</strong>：按照请求出现的顺序将请求相对均匀地分配给不同的电梯，对于无法分配电梯的策略，则在<code>sleep()</code>一段时间后将该请求放回总仓库请求队列，等待下一轮分配</li>
<li>检查电梯是否经过双轿厢改造，如果经过了改造，则在正常条件的基础上进一步要求请求的起始楼层处于改造后的电梯运行范围内</li>
</ul>
<p>本人的调度策略较为简单，并未设计更加精巧的分派策略，但是在研讨课后，本人从其他组员的描述中收获了不少调度策略的新想法：</p>
<ul>
<li><strong>优先分配空电梯</strong>：如果当前有多个电梯可以接受乘客请求，则优先选择正处于<code>WAIT</code>状态的电梯，让乘客请求及时得到响应</li>
<li><strong>电梯捎带</strong>：在对请求进行分配时，如果上面提到的“优先分配空电梯”不满足，即没有空电梯，则遍历所有电梯，检查是否有电梯可以将该乘客<strong>捎走</strong>(即电梯无需为了该乘客特意转向)，尽量减少电梯电量消耗</li>
<li><strong>单例模式</strong>：将所有的电梯属性打包存储在一个容器内，在该容器内设置一个函数用来评估分派请求的推荐指数，该函数以电梯状态以及请求信息为参数，最终通过比较各电梯的推荐指数，给出一个最佳的分派建议</li>
</ul>
<h3 id="四-防止轿厢碰撞"><a href="#四-防止轿厢碰撞" class="headerlink" title="四.防止轿厢碰撞"></a>四.防止轿厢碰撞</h3><ul>
<li>在电梯中间仓库中设置一个<code>boolean</code>值，如果共享楼层被占，则将该值置为<code>true</code>；如果从共享楼层中离开，则从<code>true</code>置为<code>false</code>。电梯每次移动之前，都要预先检测前方到达楼层是否为共享楼层，如果是共享楼层，则检测共享楼层是否被占，如果被占，则等待直到共享楼层空出</li>
<li>轿厢<strong>主动</strong>离开：每当轿厢要<code>WAIT</code>，则先检测当前楼层是否为共享楼层，如果是共享楼层，则强制该轿厢移动离开共享楼层</li>
</ul>
<h3 id="五-DeBug"><a href="#五-DeBug" class="headerlink" title="五.DeBug"></a>五.DeBug</h3><ul>
<li>多线程的bug无法单步调试，因此只能通过<strong>输出</strong>检查，例如：<ul>
<li>当程序没有正常结束时，在判断线程结束的分支处添加输出，查看是否正常输出</li>
<li>当请求响应时间超过规定时间时，在调用<code>wait()</code>方法处添加输出，检查等待是否正常退出</li>
<li>轮询检查，在循环处设置输出，如果输出结构大量重复输出该结果则证明存在轮询</li>
</ul>
</li>
</ul>
<h3 id="六-心得体会"><a href="#六-心得体会" class="headerlink" title="六.心得体会"></a>六.心得体会</h3><ul>
<li><p>在线程安全方面，本人在三次作业中均使用了<code>synchronized</code>关键字。通过将对共享变量的操作封装在<code>synchronized</code>块或方法中，保证了同一时刻线程互斥访问共享资源，从而解决数据不一致的问题</p>
</li>
<li><p>然而，随着三次作业程序复杂度的增加，本人发现锁的粒度对性能有很大影响，过度使用<code>synchronized</code>会导致线程之间的竞争过于激烈，从而降低程序的并发性能，因为竞争会增加等待时间</p>
</li>
<li><p>在层次化设计方面，通过本单元三次作业的迭代，本人意识到层次化设计的重要性。通过将程序划分为不同的模块，可以提高代码的可读性和可维护性。例如，上文设计架构中的<code>Strategy</code>和<code>FixStrategy</code>两个类本质上应该是<code>Elevator</code>线程类的方法类，但是为了方法分离以及增加可扩展性，本人决定将两个策略类分离出来，便于迭代和维护</p>
</li>
<li><p>此外，三次迭代作业中各个线程和仓库各司其职，在代码的迭代过程中带来了极大的便利，证明了模块化设计的重要性</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://Boomfreezing.github.io">Boom_freezing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://boomfreezing.github.io/2025/04/17/OO-Unit2/">http://boomfreezing.github.io/2025/04/17/OO-Unit2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://Boomfreezing.github.io" target="_blank">Boomfreezing</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1OO/">面向对象OO</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/">电梯调度</a></div><div class="post-share"><div class="social-share" data-image="/images/OO_Unit2/cover1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/31/OO-Unit1/" title="OO_Unit1"><img class="cover" src="/images/OO_Unit1/cover2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">OO_Unit1</div></div><div class="info-2"><div class="info-item-1">“计算器是怎么把数学表达式恒等变形展开的？”——递归下降展开数学表达式知识梳理……</div></div></div></a><a class="pagination-related" href="/2025/05/20/OO-Unit3/" title="OO_Unit3"><img class="cover" src="/images/OO_Unit3/cover12.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">OO_Unit3</div></div><div class="info-2"><div class="info-item-1">“模拟一个社交通信网络”——JML规格化设计与异常处理相关知识梳理……</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/31/OO-Unit1/" title="OO_Unit1"><img class="cover" src="/images/OO_Unit1/cover2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-31</div><div class="info-item-2">OO_Unit1</div></div><div class="info-2"><div class="info-item-1">“计算器是怎么把数学表达式恒等变形展开的？”——递归下降展开数学表达式知识梳理……</div></div></div></a><a class="pagination-related" href="/2025/05/20/OO-Unit3/" title="OO_Unit3"><img class="cover" src="/images/OO_Unit3/cover12.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-20</div><div class="info-item-2">OO_Unit3</div></div><div class="info-2"><div class="info-item-1">“模拟一个社交通信网络”——JML规格化设计与异常处理相关知识梳理……</div></div></div></a><a class="pagination-related" href="/2025/06/16/OO-Unit4/" title="OO_Unit4"><img class="cover" src="/images/OO_Unit4/cover3.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-16</div><div class="info-item-2">OO_Unit4</div></div><div class="info-2"><div class="info-item-1">“搭建一个简单的图书管理系统”——正向建模与大模型辅助设计相关知识梳理……</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Boom_freezing</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Boomfreezing"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to Boom_freezing's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#BUAA-OO-Unit2"><span class="toc-number">1.</span> <span class="toc-text">BUAA_OO_Unit2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.1.</span> <span class="toc-text">第一次作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E4%BB%BB%E5%8A%A1%E7%9B%AE%E6%A0%87%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">一.任务目标：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">二.实现方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E6%80%9D%E8%B7%AF%E9%98%90%E9%87%8A%EF%BC%9A"><span class="toc-number">1.1.3.</span> <span class="toc-text">三.思路阐释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">四.代码实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-BUG%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.1.5.</span> <span class="toc-text">五.BUG分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E8%80%A6%E5%90%88%E6%83%85%E5%86%B5"><span class="toc-number">1.1.6.</span> <span class="toc-text">六.复杂度及耦合情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">1.1.7.</span> <span class="toc-text">七.优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.2.</span> <span class="toc-text">第二次作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E4%BB%BB%E5%8A%A1%E7%9B%AE%E6%A0%87%EF%BC%9A-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">一.任务目标：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E6%80%9D%E8%B7%AF%E9%98%90%E9%87%8A%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">二.思路阐释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">三.代码实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-BUG%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.2.4.</span> <span class="toc-text">四.BUG分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E8%80%A6%E5%90%88%E6%83%85%E5%86%B5"><span class="toc-number">1.2.5.</span> <span class="toc-text">五.复杂度及耦合情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">1.2.6.</span> <span class="toc-text">六.优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.3.</span> <span class="toc-text">第三次作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E4%BB%BB%E5%8A%A1%E7%9B%AE%E6%A0%87%EF%BC%9A-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">一.任务目标：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E6%80%9D%E8%B7%AF%E9%98%90%E9%87%8A%EF%BC%9A-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">二.思路阐释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">三.代码实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-BUG%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="toc-number">1.3.4.</span> <span class="toc-text">四.BUG分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E8%80%A6%E5%90%88%E6%83%85%E5%86%B5-1"><span class="toc-number">1.3.5.</span> <span class="toc-text">五.复杂度及耦合情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90-1"><span class="toc-number">1.3.6.</span> <span class="toc-text">六.优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">1.4.1.</span> <span class="toc-text">一.时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E9%94%81%E4%B8%8E%E5%90%8C%E6%AD%A5%E5%9D%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">二.锁与同步块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E8%B0%83%E5%BA%A6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.3.</span> <span class="toc-text">三.调度器设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E9%98%B2%E6%AD%A2%E8%BD%BF%E5%8E%A2%E7%A2%B0%E6%92%9E"><span class="toc-number">1.4.4.</span> <span class="toc-text">四.防止轿厢碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-DeBug"><span class="toc-number">1.4.5.</span> <span class="toc-text">五.DeBug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A"><span class="toc-number">1.4.6.</span> <span class="toc-text">六.心得体会</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/15/C%E8%AF%AD%E8%A8%80%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%80/" title="C语言系统级编程(一)"><img src="/images/C_SYS_1/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言系统级编程(一)"/></a><div class="content"><a class="title" href="/2025/09/15/C%E8%AF%AD%E8%A8%80%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%80/" title="C语言系统级编程(一)">C语言系统级编程(一)</a><time datetime="2025-09-14T16:04:25.000Z" title="发表于 2025-09-15 00:04:25">2025-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/16/OO-Unit4/" title="OO_Unit4"><img src="/images/OO_Unit4/cover3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OO_Unit4"/></a><div class="content"><a class="title" href="/2025/06/16/OO-Unit4/" title="OO_Unit4">OO_Unit4</a><time datetime="2025-06-16T03:56:15.000Z" title="发表于 2025-06-16 11:56:15">2025-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/20/OO-Unit3/" title="OO_Unit3"><img src="/images/OO_Unit3/cover12.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OO_Unit3"/></a><div class="content"><a class="title" href="/2025/05/20/OO-Unit3/" title="OO_Unit3">OO_Unit3</a><time datetime="2025-05-20T03:36:56.000Z" title="发表于 2025-05-20 11:36:56">2025-05-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/17/OO-Unit2/" title="OO-Unit2"><img src="/images/OO_Unit2/cover1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OO-Unit2"/></a><div class="content"><a class="title" href="/2025/04/17/OO-Unit2/" title="OO-Unit2">OO-Unit2</a><time datetime="2025-04-17T09:37:47.000Z" title="发表于 2025-04-17 17:37:47">2025-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/31/OO-Unit1/" title="OO_Unit1"><img src="/images/OO_Unit1/cover2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OO_Unit1"/></a><div class="content"><a class="title" href="/2025/03/31/OO-Unit1/" title="OO_Unit1">OO_Unit1</a><time datetime="2025-03-31T02:08:15.000Z" title="发表于 2025-03-31 10:08:15">2025-03-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/header.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Boom_freezing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="9125417643" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>